# Open-David

一階述語論理に基づく仮説推論エンジンのマニュアルです。

このマニュアルは、バージョン `open-david 1.73` を対象としています。

-----

# Installation

ここではLinux環境におけるインストール環境について説明します。

まず、インストールする際には以下のソフトウェアが予めインストールされている必要があります。

- c++11 をコンパイル可能なC++コンパイラ
- 以下のうち、少なくとも一つのソルバ
	- [lp_solve](http://lpsolve.sourceforge.net/5.5/)
	- [Gurobi Optimizer](https://www.octobersky.jp/products/gurobi.html)
	- [CBC](https://projects.coin-or.org/Cbc)
	- [SCIP](http://scip.zib.de/)

また、個々のソルバについて、以下の環境変数を設定してください。

- `CPLUS_INCLUDE_PATH` :: 各ソルバのヘッダファイルのディレクトリ
- `LD_LIBRARY_PATH` :: 各ソルバのライブラリファイルのディレクトリ
- `CBC_HOME` :: CBC のインストール先
- `SCIP_HOME` :: SCIP のインストール先

CBC, SCIP については `CBC_HOME` および `SCIP_HOME` の値に基づいて、
コンパイルの際のインクルードディレクトリおよびライブラリディレクトリが設定されるため、
`CPLUS_INCLUDE_PATH` および `LD_LIBRARY_PATH` を設定する必要はありません。

コンパイルには、`make` コマンドを使用します。
この時、変数 `solver` に以下の値を設定することで、使用するILPソルバを指定してください。

- `lpsolve` :: lp_solve をコンパイル対象に含めます。
- `gurobi` :: Gurobi optimizer をコンパイル対象に含めます。
- `cbc` :: CBC をコンパイル対象に含めます。
- `scip` :: SCIP をコンパイル対象に含めます。

-----

# Command

推論エンジンの実行コマンドは、以下のような形式で記述します。

	$ ./david <MODE> <OPTIONS> <INPUTS>

各項目については以下で説明します。

## Modes

実行コマンドの最初の引数として、推論エンジンの基本的な挙動を指定します。
これをモードと呼び、以下の2種類が利用可能です。

- `compile` :: ルールを入力として受け取り、背景知識のデータベースを構築します。
- `infer` :: 観測を入力として受け取り、推論を実行します。

なお、各モード名の頭文字（`c`、`i`）もモード名として機能します。

## Common Options

推論エンジンの詳細な挙動をオプションによって指定します。
オプションの記述フォーマットは以下の通りで、通常のLinuxコマンドとほぼ同様です。

- `-x` :: 引数無しのショートオプション
- `-x yyy` :: 引数有りのショートオプション
- `--xxx` :: 引数無しのロングオプション
- `--xxx=yyy` :: 引数有りのロングオプション

ショートオプションは、推論エンジンの基本的な設定について定義されており、不正なオプションに対してはエラーを発生します。
一方でロングオプションは、個別のコンポーネントの設定に利用し、自由にパラメータを定義することができます。

基本的なオプションを以下に列挙します。

- `-k PATH` :: 背景知識のパスを指定します。全モードで必須です。
- `-H KEYWORD` :: ヒューリスティックの種別を指定します。詳細は後述します。デフォルト値は `-H basic` です。
- `-C` :: 推論モードにおいて、推論の前に背景知識のコンパイルを行います。
- `-c KEYWORDS` :: 推論時に用いるコンポーネントを指定します。詳細は後述します。
- `-o KEYWORD` :: 出力するフォーマットを変更します。デフォルト値は `-o mini` です。
	- `-o mini` :: 潜在仮説集合のうち解仮説に含まれる要素のみを出力します。
	- `-o ilp` :: ILP問題とその解を出力します。
	- `-o full` :: 解仮説に含まれない要素も含めた潜在仮説集合全体を出力します。
- `-o KEYWORD:PATH` :: 指定したパスに、指定したフォーマットの出力を書き出します。
	- `-o mini:PATH` :: 潜在仮説集合のうち解仮説に含まれる要素のみを、指定したパスに出力します。
	- `-o ilp:PATH` :: ILP問題とその解を、指定したパスに出力します。
	- `-o full:PATH` :: 解仮説に含まれない要素も含めた潜在仮説集合全体を、指定したパスに出力します。
- `-t STR` :: 入力された観測のうち、オプション引数で指定される条件にマッチする観測のみを推論の対象とします。
- `-t !STR` :: 入力された観測のうち、オプション引数で指定される条件にマッチする観測以外を推論の対象とします。
- `-T TIME` :: 推論全体でのタイムアウトを指定します。
- `-T lhs:TIME` :: 推論における潜在仮説集合生成処理のタイムアウトを指定します。
- `-T cnv:TIME` :: 推論における潜在仮説集合変換処理のタイムアウトを指定します。
- `-T sol:TIME` :: 推論におけるILP問題の最適解導出処理のタイムアウトを指定します。
- `-p` :: 推論において生成したILP問題に対して摂動法を適用します。
- `-P NUM` :: 並列処理の最大スレッド数を指定します。
- `-v INT` :: ログの詳細さを 0~5 で指定します。デフォルト値は `-v 1` です。
- `-h` :: ヘルプを出力します。

以下、個々のオプションについての補足事項を記述します。

### Component Option (`-c`)

推論モードを実行する際には、使用するコンポーネントを `-c` オプションによって指定する必要があります。
指定すべきコンポーネントには以下の3つがあります。

1. 観測から潜在仮説集合を生成するコンポーネント
2. 潜在仮説集合をILP問題へ変換するコンポーネント
3. ILP問題に対する最適解をILPソルバを用いて求めるコンポーネント

`-c` オプションでは、以上のコンポーネントを `','` で区切って指定します。
指定する順番は上記の通りです。

なお `-c` オプションを指定しなかった場合のデフォルト値は `astar,weighted,gurobi` です。
また、`-c astar,null` などのように、要素数が3個未満の場合には、残りの要素についてはデフォルト値が採用されます。

存在しないコンポーネントを指定した場合にはエラーが生成されます。
現在利用可能なコンポーネントについては、 *Components* の章を参照してください。

### Output Option (`-o`)

`-o` オプションにおける、出力ファイルの指定に関して、以下に示すプリプロセッサを使用することができます。

- `$TIME` :: プログラムを実行した時刻を表す文字列に置換されます。
    - 例： `"out/$TIME.json"` → `"out/20170602_173520.json"`
- `$DAY` :: プログラムを実行した日付を表す文字列に置換されます。
    - 例： `"$DAY/out.json"` → `"20170602/out.json"`

### Target Option (`-t`)

推論モードにおいて、推論の対象とする事例を `-t` オプションによって指定することができます。
オプション引数としてマッチング条件を記述します。

推論対象の選択は、以下のような挙動で行われます。

- 基本的には、オプション引数に名称が一致するような事例にマッチします。
- オプション引数が `*` で始まる場合は、後方一致のワイルドカードとして解釈されます。
- オプション引数が `*` で終わる場合は、前方一致のワイルドカードとして解釈されます。
- オプション引数の先頭と末尾が共に `*` の場合は、部分一致のワイルドカードとして解釈されます。
- オプション引数が `i:NUM` という形式だった場合は、インデックス番号が `NUM` に一致する事例にマッチします。
- オプション引数が `!` で始まる場合は、条件の否定を表し、条件にマッチしないものにマッチします。
- 条件の否定は、ワイルドカードやインデックス指定と、同時に使うことができます（例： `-t !i:3` ）。
- 複数回 `-t` オプションを与えた場合は、そのいずれかにマッチする事例が対象となります。

### Timeout Option (`-T`)

タイムアウトを指定する際、通常ではオプション引数は秒数を表しますが、
末尾に特定のアルファベットを記述することで、時間の単位を指定することができます。

以下にいくつかの例を提示します。

- `-T 30s` :: 30秒のタイムアウトを表します。
- `-T 1.5m` :: 1.5分＝90秒のタイムアウトを表します。
- `-T 0.5h` :: 0.5時間＝30分＝1800秒のタイムアウトを表します。

### Perturbation Option (`-p`)

ILP問題の各変数の目的関数上の係数に対して、ごく微量なノイズを加算することで、
解析速度を向上させたり、最適解が複数存在する場合に選択される解をある程度コントロールできます。

通常 `-p` オプションでは正値のノイズが加算されます。
そのため、最大化問題ではより変数が多い解が、最小化問題ではより変数が少ない解が優先して選択されるようになります。

また `-p` オプションとともにオプション `--negative-perturbation` を併用すると、負値のノイズが加算されます。
こちらの場合は、最大化問題ではより変数が少ない解が、最小化問題ではより変数が多い解が優先して選択されるようになります。

### Verbosity Option (`-v`)

Davidでは、処理の途中経過を標準エラー出力に書き出します。
この出力の詳細さを `-v` オプションで指定することができます。

- `-v 0` :: 例外発生時を除き、標準エラー出力に対する一切の出力を行いません。
- `-v 1` :: 処理の大きな区切りだけを通知します。
- `-v 2` :: 処理の区切りをより細かく通知します。
- `-v 3` :: 個々の処理の進捗や内容についても通知します。
- `-v 4` :: 一般のユーザが理解できる範囲で、最も細かく情報を通知します。
- `-v 5` :: 推論結果に直接関係しないような中間処理の内容についても通知します（開発者用）。

## Inputs

引数のうち、コマンドオプションとして解釈できなかったものは全て入力パスとして解釈されます。

また、コマンドに入力パスが一つも含まれなかった場合は、標準入力から入力を読み込みます。

-----

# Heuristics

Davidでは、推論の効率化のために、予め、背景知識における述語間の関連度を計算しておき、
推論の際にそれをヒューリスティック関数として用いながら探索を行います。

この章では、それらのヒューリスティック関数について説明します。
各ヒューリスティックの横の括弧書きの文字列が `-H` オプションで指定する場合の指定子です。

## Null Heuristic (`null`)

背景知識や述語に関わらず、常に定数値を返すようなヒューリスティック関数です。

推論の計算効率には殆ど寄与しませんが、
背景知識のコンパイルにおけるヒューリスティック関数の構築において、
全く時間がかからないという利点があります。

## Predicate Distance (`basic`)

背景知識における述語間の距離を予め計算して、それをヒューリスティック関数として用います。

このヒューリスティック関数固有の設定項目として以下があります。

- `--dist-func=KEYWORD` :: 各推論ルールによって定義される距離を与えるための関数を指定します。デフォルト値は `const` です。
    - `--dist-func=const` :: ルールに関わらず距離 `1.0` を返します。
- `--max-distance=FLOAT` :: ヒューリスティック関数が許容する距離の最大値を指定します。デフォルトでは無制限です。
- `--max-depth=INT` :: ヒューリスティック関数が許容する深さの最大値を指定します。デフォルト値は `5` です。

なお、ここでの「深さ」とは、述語間に存在するパスの個数を指します。
つまり `--dist-func=const` を用いた場合、オプション `--max-distance` と `--max-depth` は実質的に同じ意味合いを持ちます。

-----

# Components for Inference

この章では、推論モードにおいて用いられる各コンポーネントについて説明します。
各コンポーネントの横の括弧書きの文字列が `-c` オプションで指定する場合の指定子です。

## LHS Generator

観測から潜在仮説集合を生成するためのコンポーネント（*LHS-Generator*）です。

この種のコンポーネントでは、以下のオプションが共通オプションとして利用できます。

- `--max-depth=NUM` :: 観測から何段までの推論を許容するかを指定します。デフォルト値は `9` です。
- `--max-nodes=NUM` :: 潜在仮説集合を構成するノードの数の最大値を指定します。デフォルトでは無制限です。
- `--max-edges=NUM` :: 潜在仮説集合を構成するエッジの数の最大値を指定します。デフォルトでは無制限です。

現在、以下のコンポーネントが利用可能です。

### Simple Generator (`simple`)

ヒューリスティックを用いずに潜在仮説集合を生成するコンポーネントです。
Phillip における `-c lhs=depth` に対応します。

### A-Star-based Generator (`astar`)

背景知識のコンパイルにおいて構築したヒューリスティックを用いながら潜在仮説集合を生成するコンポーネントです。
Phillip における `-c lhs=a*` に対応します。

## ILP Converter

潜在仮説集合を生成するためのコンポーネント（*ILP-Converter*）です。

この種のコンポーネントにおける共通の設定項目として、以下のオプションが利用できます。

- `--disable-cost-provider-warning` :: 推論知識の重みの設定が不適切な場合に出力される警告を無効化します。
- `--disable-parallel-johnson` :: ループ検知処理における並列スレッドによる実行を無効化します。
- `--set-const-true=INT` :: 指定したインデックスのILP変数の値を `1.0` に固定します。複数指定したい場合は `,` で区切って記述してください。
- `--set-const-false=INT` :: 指定したインデックスのILP変数の値を `0.0` に固定します。複数指定したい場合は `,` で区切って記述してください。
- `--true-atom=ATOM` :: 指定した論理式に対応したILP変数の値を `1.0` に固定します。複数指定したい場合は `;` で区切って記述してください。
- `--false-atom=ATOM` :: 指定した論理式に対応したILP変数の値を `0.0` に固定します。複数指定したい場合は `;` で区切って記述してください。
- `--pseudo-positive` :: 観測において `require` に指定した論理式を充足するような解を出来る限り探索するよう制約を定義します。
- `--pseudo-negative` :: 観測において `require` に指定した論理式を充足しないような解を出来る限り探索するよう制約を定義します。


### Null Converter (`null`)

潜在仮説集合の構造情報だけを変換するコンポーネントです。
デバッグ用です。

### Weighted-Abduction Converter (`weighted`)

一般的な重み付き仮説推論の評価関数に基づいて、潜在仮説集合をILP問題に変換するコンポーネントです。

設定項目として以下のオプションが利用できます。

- `--default-cost` :: 観測コストのデフォルト値を指定します。デフォルトでは `10.0` です。
- `--default-weight` :: 推論知識の重み合計値のデフォルト値を指定します。デフォルトでは `1.2` です。
- `--legacy-loop-prevention` :: 説明のループを抑制するためのILP制約の定義方法として `ver.1.23` 以前のものを使います。

### Cost-based Abduction Converter (`linear`)

コストに基づく仮説推論の評価関数に基づいて、潜在仮説集合をILP問題に変換するコンポーネントです。

設定項目として *Weighted-Abduction Converter* と同様のオプションが利用できます。

### Probabilistic Cost-based Abduction (`prob-cost`)

確率が付与された背景知識を用いてコストに基づく仮説推論を行うためのコンポーネントです。

設定項目として *Weighted-Abduction Converter* と同様のオプションが利用できます。

### Etcetera-Abduction Converter (`etc`, `etcetera`)

*Etcetera Abduction* の評価関数に基づいて、潜在仮説集合をILP問題に変換するコンポーネントです。
`ver.1.67` から利用可能です。

このコンポーネントでは、観測がクエリかファクトかによって、評価関数上の扱いが異なります。
ファクトに付与された実数値パラメータは、ファクトの生起確率として解釈されます。
クエリに付与された実数値パラメータは無視されます。

このコンポーネントでは、設定項目として以下のオプションが利用できます。

- `--default-weight` :: ファクトおよび推論知識の成立確率のデフォルト値を指定します。デフォルトでは `1.0` です。

### CEAEA Converter (`ceaea`)

*Cost-based Etcetera and Anti-Etcetera Abduction* の評価関数に基づいて、潜在仮説集合をILP問題に変換するコンポーネントです。
`ver.1.67` から利用可能です。

このコンポーネントでは、観測がクエリかファクトかによって、評価関数上の扱いが異なります。
個々の観測論理式に付与された実数値パラメータは、クエリに対しては報酬値として、ファクトに対しては生起確率として解釈されます。

このコンポーネントでは、設定項目として以下のオプションが利用できます。

- `--default-probability` :: ファクトの生起確率のデフォルト値を指定します。デフォルトでは `1.0` です。
- `--default-query-reward` :: クエリの報酬値のデフォルト値を指定します。デフォルトでは `1.0` です。
- `--default-reward` :: クエリを全く説明できなかった時に与えられる報酬値を指定します。デフォルトでは `1.0` です。
- `--default-backward-weight` :: ルールが後ろ向きに成り立つ確率のデフォルト値を指定します。デフォルトでは `0.8` です。
- `--default-forward-weight` :: ルールが前向きに成り立つ確率のデフォルト値を指定します。デフォルトでは `1.0` です。
- `--default-weight` :: ルールが前向きあるいは後ろ向きに成り立つ確率のデフォルト値を一括で指定します。

なお `--default-backward-weight` および `--default-forward-weight` を `--default-weight` と併用した場合は、
前者で設定した値が優先して用いられます。

## ILP Solver

ILP問題の最適解を導出するためのコンポーネント（*ILP-Solver*）です。

### Null Solver (`null`)

何もしないコンポーネントです。
最適解を必要としない場合などに用います。

### Lp-Solve (`lpsolve`)

フリーのILPソルバである[lp_solve](http://lpsolve.sourceforge.net/5.5/)を用いて最適解を導出します。
lp_solveが利用できない環境下ではエラーを生成します。

設定項目として、以下のオプションが利用可能です。

- `--print-lpsolve-log` :: 通常では lp_solve が出力するログは表示されませんが、それを表示します。

### Gurobi (`gurobi`)

商用のILPソルバである[Gurobi Optimizer](https://www.octobersky.jp/products/gurobi.html)を用いて最適解を導出します。
Gurobi Optimizerが利用できない環境下ではエラーを生成します。

`-P` オプションを用いて並列スレッド数が指定されていた場合、コンポーネントはその値をGurobi Optimizerにも通知します。

設定項目として、以下のオプションが利用可能です。

- `--print-gurobi-log` :: 通常ではGurobi Optimizerが出力するログは表示されませんが、それを表示します。

### Gurobi with Cutting Plane Inference (`gurobi-cpi`)

Gurobi Optimizerを用いて、[Cutting Plane Inference](http://www.cl.ecei.tohoku.ac.jp/~naoya-i/resources/jelia2012_paper.pdf)によって最適解を導出します。
Gurobi Optimizerが利用できない環境下ではエラーを生成します。

多くの場合において、CPIを用いない場合よりも効率的な推論が実現できますが、
一方で、タイムアウトした場合に解の無矛盾性が失われるという欠点があります。

設定項目としては、CPIを用いないもの（`gurobi`）と同様のオプションが利用可能です。
`-P` オプションを用いて並列スレッド数が指定されていた場合、コンポーネントはその値をGurobi Optimizerにも通知します。

### K-best Solver with Gurobi (`gurobi-kbest`)

Gurobi Optimizerを用いて、複数の解を評価関数が高い順に導出します。
Gurobi Optimizerが利用できない環境下ではエラーを生成します。

新たな解が導出できなくなるか、解の個数が予め指定した数に達した時点で推論を終了します。

また解の探索は、個々の解の間に一定以上の差異が存在するように行われます。
具体的には、それぞれの解ペアについて、予め定めた何らかの自然数をマージンとしたとき、どちらか片方にしか含まれないノードの個数がマージンの値以上にならなければなりません。

設定項目としては、通常のもの（`gurobi`）と同様のオプションが利用可能なほか、固有のオプションとして以下が利用可能です。

- `--max-solution-num=INT` :: 導出したい解の個数の最大値を指定します。デフォルト値は `5` です。
- `--max-eval-delta=FLOAT` :: 最適解の評価関数値からどこまで離れた解を出力として許容するかを指定します。デフォルト値は `5.0` です。
- `--eval-margin=INT` :: 個々の解の間のマージン値を指定します。デフォルト値は `3` です。

### K-best Solver with Gurobi and CPI (`gurobi-kbest-cpi`)

*K-best Solver with Gurobi* の推論において、[Cutting Plane Inference](http://www.cl.ecei.tohoku.ac.jp/~naoya-i/resources/jelia2012_paper.pdf)を利用するバージョンです。

設定項目としては、CPIを用いないもの（`gurobi-kbest`）と同様のオプションが利用可能です。
`-P` オプションを用いて並列スレッド数が指定されていた場合、コンポーネントはその値をGurobi Optimizerにも通知します。

### SCIP (`scip`)

フリーのILPソルバである[SCIP](http://scip.zib.de/)を用いて最適解を導出します。
SCIPが利用できない環境下ではエラーを生成します。

設定項目として、以下のオプションが利用可能です。

- `--gap-limit` :: 最適値として許容するギャップ値を指定します。デフォルトではSCIP内部のデフォルト値です。

### SCIP with Cutting Plane Inference (`scip-cpi`)

SCIPを用いて、[Cutting Plane Inference](http://www.cl.ecei.tohoku.ac.jp/~naoya-i/resources/jelia2012_paper.pdf)によって最適解を導出します。
SCIPが利用できない環境下ではエラーを生成します。

多くの場合において、CPIを用いない場合よりも効率的な推論が実現できますが、
一方で、タイムアウトした場合に解の無矛盾性が失われるという欠点があります。

設定項目としては、CPIを用いないもの（`scip`）と同様のオプションが利用可能です。

### K-best Solver with SCIP (`scip-kbest`)

SCIPを用いて、複数の解を評価関数が高い順に導出します。
SCIPが利用できない環境下ではエラーを生成します。

ソルバとしてSCIPを使うこと以外は、*K-best Solver with Gurobi*と同様です。

設定項目としては、通常のもの（`scip`）と同様のオプションが利用可能なほか、*K-best Solver with Gurobi*に示すオプションが利用可能です。

### K-best Solver with SCIP and CPI (`scip-kbest-cpi`)

*K-best Solver with SCIP*の推論において、[Cutting Plane Inference](http://www.cl.ecei.tohoku.ac.jp/~naoya-i/resources/jelia2012_paper.pdf)を利用するバージョンです。

設定項目としては、CPIを用いないもの（`scip-kbest`）と同様のオプションが利用可能です。

### CBC (`cbc`)

フリーのILPソルバである[CBC](https://projects.coin-or.org/Cbc)を用いて最適解を導出します。
CBCが利用できない環境下ではエラーを生成します。

設定項目として、以下のオプションが利用可能です。

- `--gap-limit` :: 最適値として許容するギャップ値を指定します。デフォルトではCBC内部のデフォルト値です。

### CBC with Cutting Plane Inference (`cbc-cpi`)

CBCを用いて、[Cutting Plane Inference](http://www.cl.ecei.tohoku.ac.jp/~naoya-i/resources/jelia2012_paper.pdf)によって最適解を導出します。
CBCが利用できない環境下ではエラーを生成します。

多くの場合において、CPIを用いない場合よりも効率的な推論が実現できますが、
一方で、タイムアウトした場合に解の無矛盾性が失われるという欠点があります。

設定項目としては、CPIを用いないもの（`cbc`）と同様のオプションが利用可能です。

### K-best Solver with CBC (`cbc-kbest`)

CBCを用いて、複数の解を評価関数が高い順に導出します。
CBCが利用できない環境下ではエラーを生成します。

ソルバとしてCBCを使うこと以外は、*K-best Solver with Gurobi*と同様です。

設定項目としては、通常のもの（`cbc`）と同様のオプションが利用可能なほか、*K-best Solver with Gurobi*に示すオプションが利用可能です。

### K-best Solver with CBC and CPI (`cbc-kbest-cpi`)

*K-best Solver with CBC*の推論において、[Cutting Plane Inference](http://www.cl.ecei.tohoku.ac.jp/~naoya-i/resources/jelia2012_paper.pdf)を利用するバージョンです。

設定項目としては、CPIを用いないもの（`cbc-kbest`）と同様のオプションが利用可能です。

-----

# Other Options

この章では、雑多なオプションについて説明します。

### `--disable-kb-cache`

`ver.1.62` 以降のDavidでは、データベースから読み込んだルールをメモリにキャッシュする機能がデフォルトでONになっています。
このオプションを指定することでその機能を無効化します。

-----

# Input files

推論エンジンの入力は、独自のシンタクスによって記述します。
このシンタクスはC++やJavascriptを若干踏襲してデザインされています。

なお、入力ファイルの各行において `#` より後ろの文字列は、コメントとして無視されます。

## Atoms

観測やルールの中で現れる原子論理式は、C++などにおける関数呼び出しと似た形式で記述されます。
例えば `dog(x)` や `eat(x, y)` のように記述されます。

Davidでは、2種類の否定、即ち Typical Negation および Negation as Failure が利用可能です。
Typical Negation は述語の前に `!` を置くことで記述します。
Negation as Failure は述語の前に `not` を置くことで記述します。

以下にいくつかの例を示します。

- `dog(x)` :: 変数 `x` は犬である
- `!dog(x)` :: 変数 `x` は犬ではない
- `not dog(x)` :: 変数 `x` が犬であることが示されていない
- `not !dog(x)` :: 変数 `x` が犬でないことが示されていない

また、論理式の引数には、英数字およびアンダーバーで構成された文字列あるいは、
引用記号で囲まれた文字列が利用可能です。
それぞれの引数が定数と変数のどちらかとして解釈されるかは、以下の基準で決定されます。

1. 引用符で囲まれているなら、定数
2. 引用符で囲まれておらず、小文字から始まるなら、変数
3. それ以外は、定数

例外として、引用符で囲まれておらず、かつアンダーバーで始まる場合には、
アンダーバーを無視した引数名に関して上記の判定が行われます。

また、各論理式には、パラメータを与えることができます。
パラメータは、論理式の直後に `:` から始まる文字列を記述することで定義できます。
例えば `dog(x):hoge` と書くと、パラメータ `hoge` を持つ論理式 `dog(x)` が定義されます。

また、複数のパラメータを定義したい場合は、例えば `dog(x):foo:var` のように、
各パラメータを `:` で区切って記述してください。

パラメータは、観測におけるコストや、ルールにおける重みを記述する際に用います。

Typical Negation は基本的にどこでも記述可能ですが、
Negation as Failure はルールの記述でしか利用できません。

## Conjunctions

原子論理式の連言は、例えば `{ dog(x) ^ cat(y) }` のように、
波括弧（`{}`）で囲んだ中に、各論理式を `^` で区切って記述することで書き表します。
波括弧は、ルールの定義内でのみ省略可能です。

また、論理式と同様に、連言に対してもパラメータを与えることができます。
パラメータを与えるには、波括弧を省略せずに連言を記述し、
その直後に `:` から始まる文字列を記述します。

例えば `{ dog(x) ^ cat(y) }:hoge` などと書くと、
連言に対してパラメータ `hoge` が定義されます。

## Rules

まず最初に、簡単な例を次に示します。

	rule monkey_likes_banana { { monkey(x) } => { eat(x, y) ^ banana(y) }}

ルールを定義するには、まず文頭で `rule` と記述します。
その後、これから定義するルールの名称を記述します。
上の例では `monkey_likes_banana` がルールの名称となります。
ルールの名称は主に出力で用いられ、多くの場合、推論内容に影響を及ぼすものではありません。
（推論内容に影響が生じる場合もあります。詳細は *Advanced Functions* の章を参照してください。）

ルール本体は、波括弧で囲んだ中に記述し、前件と後件の間は `=>` で区切ります。
前述したとおり各連言の波括弧は省略でき、例えば上の例は以下のようにも書くことができます。

	rule monkey_likes_banana { monkey(x) => eat(x, y) ^ banana(y) }

また、ルールの重みはパラメータを用いて定義します。
連言に与えた場合は、重みの合計値がその値になるよう、各論理式に均等に重みが与えられます。

特殊な記述として、後件に `false` と書くことで、前件が成り立つ場合に矛盾を導くことを表します。
これにより、例えば `dog(x) ^ cat(x) => false` のようにして、推論の中での制約を定義することができます。

### Negation as Failure in Rules

ルールを定義する際には、Negation as Failure (NAF) を含めることができます。

    rule { p(x) ^ not r(x) => q(x) ^ not s(x) }

ルール定義中に現れるNAFは、記述位置に関わらず、
Typical Negation に置き換えた上で推論結果として仮説されます。
例えば上記のルールを `p(y)` に前向き適用する場合、`q(y) ^ !r(x) ^ !s(y)` が仮説されます。
一方、同じルールを `q(y)` に後ろ向き適用する場合、`p(y) ^ !r(y) ^ !s(y)` が仮説されます。

> NAFを Typical Negation に置き換えているのは、Closed World Assumption (CWA) を仮定しているためです。
> これは、真偽値が `unknown` となるのは、実用的には真偽値が推論に関与しない論理式のみであるべきである、という思想に基づいています。

なお、後件をNAFだけで構成した場合、そのルールは後ろ向き推論で用いられません。
なぜなら、後ろ向き推論における後件のNAFは前提条件として扱われるため、そのルールは実質的に後件が空のルールとなるためです。
同様に、前件をNAFだけで構成した場合は、そのルールは前向き推論で用いられません。

### Equality in Rules

ルールを定義する際には、等価関係を含めることができます。

    rule { p(x) ^ (x = A) => q(y) ^ (x != y) ^ not (y = B) }

ルール定義中に現れる等価関係は、否定の有無、記述位置などによって振る舞いが変化します。
まず、前提側に記述された場合は、ルール適用の前提条件として扱われます。
一方で結果側に記述された場合は、推論結果として仮説されます。
この時、NAFで否定されている場合には Typical Negation に置き換えます。

ただし、例外として、等価関係が前提に含まれる場合であっても、
ルールの適用前の時点で不定な変数がその等価関係の引数に含まれるならば、結果側にあるものとして扱います。
即ち、適用条件としては扱われず、推論結果として仮説されます。

例えば、上述のルールを `p(s)` に前向き適用する場合、ルール適用のための前提条件は `(s = A)` であり、
適用結果としては `q(_u) ^ (s != _u) ^ (_u != B)` が導出されます。
一方、このルールを `q(s)` に後ろ向き適用する場合は、ルール適用の前提条件は `not (s = B)` であり、
適用結果として `p(_u) ^ (_u = A) ^ (s != _u)` すなわち `p(A) ^ (s != A)` が導出されます。
この時、`(s != _u)` は後ろ向き推論においては前提側に存在していますが、
その引数である変数 `_u` はルール適用前の時点で不定であるので、前提条件ではなく推論結果として扱っています。

なお、Negation as Failure と同様に、ルールの前件や後件を等価関係だけで構成した場合、
そのルールは後ろ向き推論あるいは前向き推論で用いられません。

### Rules as Constraints

定義されたルールは、推論中に守るべき制約としても扱われます。例えば、次のルールを考えます。

    rule r1 { p(x) ^ q(x) => false }
	rule r2 { s(x) => t(x) }

これらのルールを含んだ背景知識を用いた推論では、まずルール `r1` により、
任意の変数 `x` に対して `p(x) ^ q(x)` を満たすような仮説は、矛盾を導くものとして抑制されます。
また、ルール `r2` と矛盾するもの、即ち任意の変数 `x` に対して `s(x) ^ !t(x)` を満たす仮説についても、
同様に矛盾を導くものとして抑制されます。

このように、Davidの推論においては、それぞれのルールについて
「前件が成り立ち、かつ後件のうち少なくとも一つが否定されるなら、矛盾を導く」という制約が考慮されます。

Negation as Failure が含まれる場合も、基本的には同じように扱います。
例えば、次のルールを考えます。

    rule r3 { p(x) ^ not s(x) => q(x) ^ not t(x) }

このルールにより、任意の変数 `x` に対して以下の制約が課されます。

    p(x) ^ not s(x) ^ q(x) => false
    p(x) ^ not s(x) ^ t(x) => false

このとき `not !p` は `p` と等価であることに留意してください。

なお、前件に含まれない変数が後件に存在するようなルールについては、制約定義の対象から除外されます。
なぜなら、そのような場合に後件を否定されるためには、全ての変数について後件が否定されることを示す必要があるためです。

## Observations

まず最初に、簡単な例を次に示します。

	problem test {
	    observe { go(x,Store) ^ have(x,Gun) }
	    require { robbing(x) }
	}

観測を定義するには、まず文頭で `problem` と記述した後、その事例の名称を記述します。
上の例では `test` が観測の名称となります。

波括弧の内部では、以下の4つの要素を定義することが可能です。

- `observe` :: 観測を定義する。
- `fact` :: 観測のうちファクトを定義する。
- `query` :: 観測のうちクエリを定義する。
- `require` :: ここで指定した連言を解仮説が含むかどうかを、出力の際にチェックする。

評価関数によっては、ファクトとして与えるかクエリとして与えるかによって評価上の扱いが変化するため、
内部的に観測は常にファクトとクエリに分けて保持されます。
`observe` を用いて観測を定義した場合、等価関係を表す論理式はファクトとして、それ以外の論理式はクエリとして扱われます。

推論を行う際はクエリを指定することが必須となります。
そのため、`observe` または `query` は常に指定する必要があります。

### Forall

`ver.0.53` より、観測の記述において `forall` が記述できるようになりました。
簡単な例を以下に示します。

    problem test {
		observe { man(A) ^ man(B) ^ forall !have(x,Gun) }
	}

この例は、論理式 `\exists A, B, Gun \forall x { man(A) ^ man(B) ^ !have(x,Gun) }` と等価です。
そのため、任意の変数 `x` に対して論理式 `have(x,Gun)` を満たすような仮説は、全て仮説候補から除外されます。

なお、同じ原子論理式に対して `forall` と `not` を同時に指定することはできません。

> `forall not A` は実用上 `forall !A` で代用可能であることから、実装の都合上 `forall not` は使用不可としています。

### Any

`ver.1.11` より `require` 要素の記述における変数として任意変数 `any` が使えるようになりました。

`require` 要素における論理式の引数として `any` を記述した場合、この引数は「任意の変数あるいは定数」として解釈されます。
例えば `p(x, any)` などと記述したとき、このクエリは述語 `p` を持ち、第一引数に変数 `x` を持ち、第二引数に**任意の変数あるいは定数**を持つ論理式にマッチします。

## Numerical Arguments

`ver.0.92` より、数量表現を部分的に扱えるようになりました。

論理式の引数として `15` のような整数値を与えることが可能なほか、ルールにおいて `p(x+5) => q(x)` のように記述することで、数値計算が可能です。
例えばこのルールを論理式 `q(20)` に後ろ向き適用した場合、論理式 `p(25)` が仮説されます。

数値計算については、現在は足し算と引き算のみに対応しています。
例えばルール `p(x+5) => q(x)` と `p(x) => q(x-5)` は互いに等価です。
変数同士の数値計算（e.g. `p(x+y)`）は出来ません。

なお、数値計算を含むルールを数値表現でない引数に適用した場合は、数値計算は無視され、通常の処理が適用されます。
例えばルール `p(x+5) => q(x)` を論理式 `q(A)` に後ろ向き適用した場合は、論理式 `p(_u)` が生成されます。

また、`x+5` のような数値を含む変数は、ルールの中でしか用いることができません。
観測に記述した場合は例外が送出されます。

> `x+5` や `A-3` などといった数量表現付きの引数を仮説中で扱おうとすると、変数間の等価関係が非常に扱いづらくなるため、このような仕様にしています。

## Predicate Properties

個々の述語が持つ性質を定義し、推論に反映させることができます。
まず最初に、簡単な例を次に示します。

    property pred/3 { transitive:2, symmetric:1:3 }

上の例では、3つの引数をとるような述語 `pred` において、
2番目と3番目の引数の間に推移律が、
1番目と3番目の引数の間に対称律が成り立つことを表しています。

述語の性質を定義するには、まず文頭で `property` と記述した後、対象となる述語を指定します。
述語を指定するには、述語自体と、述語がとる引数の数を、記号 `/` で区切って記述します。
例えば `dog(x)` における述語を指定するには `dog/1` と書きます。

波括弧の内部では、先ほど指定した述語が持つ性質を、コンマ区切りで記述します。
それぞれの性質は、性質の名称と、その性質を持つ引数のインデックスを `:` で区切る形で記述します。

何らかの二項関係に対応する性質については、2つ目のインデックスを省略した場合、
1つ目のインデックスで指定した引数の次の引数が自動的に指定されます。
例えば `symmetric:1` は `symmetric:1:2` と同義です。

現在利用できるものは以下の通りです。

- `transitive` :: 指定された引数ペアの間に、推移律が成り立つ。
- `symmetric` :: 指定された引数ペアの間に、対称律が成り立つ。
- `asymmetric` :: 指定された引数ペアの間に、非対称律が成り立つ。
- `irreflexive` :: 指定された引数ペアの間に、非反射律が成り立つ。
- `right-unique` :: 指定された引数ペアの間に、右一意的な関係が成り立つ。
- `left-uniqe` :: 指定された引数ペアの間に、左一意的な関係が成り立つ。
- `closed` :: 指定された引数は何らかの定数と等価でなければならない。
- `abstract` :: 指定された位置の引数同士の単一化のみから等価仮説を導くことはできない。

なお、対称律と非対称律など、
同時に成り立ち得ない性質を同じ引数に指定してしまうと、エラーが生成されます。

## Mutual Exclusions

実問題においては、同じ上位概念を持つ述語集合の各ペア間に、一括して相互排他性を定義したい場合があります。
`mutual-exclusion` キーワードは、そのような場合に有用な機能です。

簡単な例を以下に示します。

    mutual-exclusion animal { dog(x) v cat(x) v mouse(x) }

この例は、以下のルール群と等価です。

    rule animal { dog(x) ^ cat(x) => false }
	rule animal { cat(x) ^ mouse(x) => false }
	rule animal { mouse(x) ^ dog(x) => false }

この機能を用いる際の注意点は以下の通りです。

- ルール名称（上の例における `animal` に対応）は省略することができます。
- 選言の中に等価関係を表すリテラルは含めることが出来ません。
- 選言に含まれる個々のリテラルにおいて、少なくとも一つの変数が共有されていなくてはなりません。

## Emacs Mode

David のパッケージでは、入力ファイルを編集するためのEmacsモードを提供しています。

`tools/david-mode.el` を自身の設定ファイルに追加することで、入力ファイル用のモードが追加されます。
一般的には、`~/.emacs` または `~/.emacs.d/init.el` に、以下の命令を記述します。
なお、引数は、設定ファイルから `david-mode.el` への相対パスとして適切な値に置き換えてください。

	(load "tools/david-mode.el")

デフォルトでは、拡張子が `*.dav` のファイルがモードの対象となっています。

-----

# Output files

推論エンジンの出力は、JSON形式で記述されます。

出力の形式は `-o` オプションで指定することができ、現在は以下の3形式で出力が可能です。

- `mini` :: 解仮説に含まれる要素のみを、証明木として出力します。
- `full` :: 潜在仮説集合に含まれる全ての要素を、証明木として出力します。
- `ilp` :: 推論結果を、ILP問題とその解として出力します。

出力されるJSONオブジェクトは以下のような要素を持ちます。

- `"output-type"` :: 出力の形式を表します。
- `"kernel"` :: 推論エンジンのメタ情報を表します。
	- `"version"` :: 推論エンジンのバージョンを表します。
	- `"executed"` :: 推論エンジンが実行された日時を表します。
	- `"lhs-generator"` :: 潜在仮説集合を生成するのに用いたコンポーネントに関する情報を表します。
	- `"ilp-converter"` :: 潜在仮説集合をILP問題に変換するのに用いたコンポーネントに関する情報を表します。
	- `"ilp-solver"` :: ILP問題の解を導出するのに用いたコンポーネントに関する情報を表します。
	- `"tuner"` :: 学習に用いたコンポーネントに関する情報を表します。
- `"knowledge-base"` :: 推論で用いた背景知識の情報を表します。
	- `"path"` :: 背景知識のファイルパスを表します。
	- `"version"` :: 背景知識のバージョンを表します。
	- `"rules-num"` :: 背景知識に含まれるルールの数を表します。
	- `"predicates-num"` :: 背景知識に含まれる述語の数を表します。
	- `"compiled"` :: 背景知識がコンパイルされた日時を表します。
- `"results"` :: 各問題に対する推論結果を、配列で表します。各項目は以下のような要素を持ちます。
    - `"epoch"` :: 学習における、現在のエポック数を表します。
	- `"index"` :: その問題のインデックス番号です。
	- `"name"` :: その問題の名称です。
	- `"elapsed-time"` :: その問題に対する推論にかかった時間を表します。単位は秒です。
		- `"lhs"` :: 潜在仮説集合の生成にかかった時間を表します。
		- `"cnv"` :: 潜在仮説集合のILP問題への変換にかかった時間を表します。
		- `"sol"` :: ILP問題の解の導出にかかった時間を表します。
		- `"all"` :: 推論全体でかかった時間を表します。
	- `"solution"` :: 推論結果を表します。推論結果の個数が `1` 以外の場合は省略されます。
	- `"solutions"` :: 推論結果を配列で表します。推論結果の個数が複数存在しない場合は省略されます。
	- `"failed"` :: 学習において、正例と負例が正しく得られたかどうかを表します。

要素 `solution` または `solutions` の構造は `-o` オプションで指定された形式に応じて変化します。
詳細については以下で詳述します。

## Minimal Proof Graphs

`-o mini` オプションを指定した時の、推論結果を表すJSONオブジェクトは、以下の要素を持ちます。

- `"state"` :: 得られた解の状態を記述します。
    - `"optimal"` :: 潜在仮説集合に対して最適な解が得られていることを表します。
	- `"sub-optimal"` :: タイムアウトなどの理由により最適ではないものの、解としては有効であることを表します。
	- `"not-available"` :: 満たすべき制約が満たされていないなど、解として使えない出力であることを表します。
- `"objective"` :: 得られた解における評価関数の値を表します。
- `"size"` :: 潜在仮説集合のサイズ、すなわちノードやエッジの数を記述します。
	- `"node"` :: ノードの数を表します。
	- `"hypernode"` :: ハイパーノードの数を表します。
	- `"rule"` :: この潜在仮説集合において使われているルールの種類数を表します。
	- `"edge"` :: エッジの数を表します。
	- `"exclusion"` :: 排他制約の数を表します。
- `"requirement"` :: 観測に `require` 要素が指定されている場合、その充足状態を表します。
	- `"satisfied"` :: `require` 要素が全て充足されているかどうかを表します。
	- `"detail"` :: それぞれの `require` 要素の充足状態を表します。
- `"nodes"` :: 解仮説に含まれるノードを、配列として列挙します。
- `"hypernodes"` :: 解仮説に含まれるハイパーノードを、配列として列挙します。
- `"edges"` :: 解仮説に含まれるエッジを、配列として列挙します。
- `"rules"` :: 潜在仮説集合の中で用いられているルールを、配列として列挙します。
- `"violated"` :: 潜在仮説集合に含まれる排他制約のうち、解仮説が違反しているものを、配列として列挙します。
- `"cost-payment"` :: コスト最小化に基づく評価関数を用いている場合、この要素を持ちます。個々のノードに割り当てられたコストの支払いに関する情報を列挙します。

各要素の定義については以下で詳述します。

## Full Proof Graphs

`-o full` オプションを指定した時の、推論結果を表すJSONオブジェクトは、以下の要素を持ちます。

- `"state"` :: 得られた解の状態を記述します。
    - `"optimal"` :: 潜在仮説集合に対して最適な解が得られていることを表します。
	- `"sub-optimal"` :: タイムアウトなどの理由により最適ではないものの、解としては有効であることを表します。
	- `"not-available"` :: 満たすべき制約が満たされていないなど、解として使えない出力であることを表します。
- `"objective"` :: 得られた解における評価関数の値を表します。
- `"size"` :: 潜在仮説集合のサイズ、すなわちノードやエッジの数を記述します。
	- `"node"` :: ノードの数を表します。
	- `"hypernode"` :: ハイパーノードの数を表します。
	- `"rule"` :: この潜在仮説集合において使われているルールの種類数を表します。
	- `"edge"` :: エッジの数を表します。
	- `"exclusion"` :: 排他制約の数を表します。
- `"requirement"` :: 観測に `require` 要素が指定されている場合、その充足状態を表します。
	- `"satisfied"` :: `require` 要素が全て充足されているかどうかを表します。
	- `"detail"` :: それぞれの `require` 要素の充足状態を表します。
- `"active"` :: 解仮説に含まれる要素を記述します。
    - `"nodes"` :: 解仮説に含まれるノードを、配列として列挙します。
    - `"hypernodes"` :: 解仮説に含まれるハイパーノードを、配列として列挙します。
    - `"edges"` :: 解仮説に含まれるエッジを、配列として列挙します。
- `"not-active"` :: 潜在仮説集合に含まれる要素のうち、解仮説に含まれない要素を記述します。
    - `"nodes"` :: 解仮説に含まれないノードを、配列として列挙します。
    - `"hypernodes"` :: 解仮説に含まれないハイパーノードを、配列として列挙します。
    - `"edges"` :: 解仮説に含まれないエッジを、配列として列挙します。
- `"rules"` :: 潜在仮説集合の中で用いられているルールを、配列として列挙します。
- `"exclusions"` :: 潜在仮説集合に含まれる排他制約を記述します。
    - `"satisfied"` :: 潜在仮説集合に含まれる排他制約のうち、解仮説が充足しているものを、配列として列挙します。
    - `"violated"` :: 潜在仮説集合に含まれる排他制約のうち、解仮説が違反しているものを、配列として列挙します。
- `"cost-payment"` :: コスト最小化に基づく評価関数を用いている場合、この要素を持ちます。個々のノードに割り当てられたコストの支払いに関する情報を列挙します。

各要素の定義については以下で詳述します。

## ILP Solutions

`-o ilp` オプションを指定した時の、推論結果を表すJSONオブジェクトは、以下の要素を持ちます。

- `"maximize"` :: 最大化問題か最小化問題なのかを表します。値が `true` なら最大化問題です。
- `"economize"` :: 変数の数を節約する機能が使われているかどうかを表します。
- `"objective"` :: 得られた解における目的関数の値を表します。
- `"state"` :: 得られた解の状態を記述します。
    - `"optimal"` :: 潜在仮説集合に対して最適な解が得られていることを表します。
	- `"sub-optimal"` :: タイムアウトなどの理由により最適ではないものの、解としては有効であることを表します。
	- `"not-available"` :: 満たすべき制約が満たされていないなど、解として使えない出力であることを表します。
- `"size"` :: このILP問題の規模、即ち変数や制約の個数を表します。
	- `"variable"` :: ILP変数の数を表します。
	- `"constraint"` :: ILP制約の数を表します。
- `"variables"` :: このILP問題に含まれる変数を表します。以下の要素から成ります。
	- `"positive"` :: 変数のうち、値が `0.0` でないものを配列で表現します。
	- `"negative"` :: 変数のうち、値が `0.0` であるものを配列で表現します。
- `"constraints"` :: このILP問題に含まれる制約を表します。以下の要素から成ります。
	- `"satisfied"` :: 制約のうち、充足されているものを配列で表現します。
	- `"violated"` :: 制約のうち、充足されなかったものを配列で表現します。

各要素の定義については以下で詳述します。

## Atoms

各原子論理式は、JSONオブジェクト上では（例えば `"not dog(x)"` のように）文字列として表現されます。

これは、出力ファイルのサイズを抑えるための措置です。
そのため、出力ファイルから得られる論理式に対して何らかの論理演算を行いたい場合は、
スクリプト側で適宜論理式のパージングを行ってください。

## Conjunctions

原子論理式の連言は、文字列の配列として表現されます。

例えば、論理式 `dog(x) ^ cat(y)` は、`[ "dog(x)", "cat(y)" ]` と変換されます。

## Rules

ルールを表すJSONオブジェクトは、以下の要素を持ちます。

- `"rid"` :: このルールの、背景知識におけるID番号を表します。
- `"name"` :: このルールの名称を表します。入力ファイルで定義されている場合はその名前を、されていない場合は自動で採番した名称を記述します。
- `"class"` :: このルールが属するクラスを表します。どのクラスにも属さない場合、この要素は省略されます。
- `"left"` :: このルールの左辺にある連言を、文字列の配列によって表します。
- `"right"` :: このルールの右辺にある連言を、文字列の配列によって表します。
- `"cond"` :: このルールの適用条件である連言を、文字列の配列によって表します。

## Nodes

証明木におけるノードを表すJSONオブジェクトは、以下の要素を持ちます。

- `"index"` :: 潜在仮説集合における、このノードを指すインデックス番号です。
- `"type"` :: このノードがどのタイプのノードであるかを表します。
	- `"observable"` :: 観測に含まれていることを表します。
	- `"hypothesized"` :: 推論によって仮説されたものであることを表します。
- `"atom"` :: このノードに対応する原子論理式を表します。
- `"depth"` :: このノードの深さ、即ち観測からこのノードまでに経由するエッジの個数を表します。
- `"master"` :: このノードのマスターハイパーノードのインデックス番号を表します。

マスターハイパーノードとは、ノードが潜在仮説集合に追加される時に、
それを要素の一つとして同時に追加されるようなハイパーノードを指します。
そのため、ノードの有無と、そのマスターハイパーノードの有無は、常に一致します。

## Hypernodes

証明木におけるハイパーノードを表すJSONオブジェクトは、以下の要素を持ちます。

- `"index"` :: 潜在仮説集合における、このハイパーノードを指すインデックス番号です。
- `"nodes"` :: このハイパーノードに含まれる各ノードのインデックス番号を、配列で保持しています。

## Edges

証明木におけるエッジを表すJSONオブジェクトは、以下の要素を持ちます。

- `"index"` :: 潜在仮説集合における、このエッジを表すインデックス番号です。
- `"type"` :: このエッジがどのタイプであるかを表します。
	- `"hypothesize"` :: 後ろ向き推論であることを表します。
	- `"implicate"` :: 前向き推論であることを表します。
	- `"unify"` :: 単一化操作であることを表します。
- `"rule"` :: このエッジで使われているルールのID番号を表します。単一化など、ルールを用いないエッジの場合は省略されます。
- `"tail"` :: このエッジの始点に対応するハイパーノードのインデックス番号です。
- `"head"` :: このエッジの終点に対応するハイパーノードのインデックス番号です。

エッジの始点は、エッジが表す操作の入力に対応し、エッジの終点は、エッジが表す操作の出力に対応します。

例えば、後ろ向き推論の場合は、ルールの右辺が `"tail"` 要素に、左辺が `"head"` 要素に対応します。
逆に前向き推論の場合は、ルールの左辺が `"head"` 要素に、右辺が `"head"` 要素に対応します。
単一化エッジの場合は、単一化されたノード対が `"tail"` 要素として、
単一化によって仮説された等価関係が `"head"` 要素として記述されます。

また、単一化操作においては、出力が空の場合がありますが、
そのような場合、`"head"` の値は `-1` となります。

## Exclusions

David における排他制約とは、例えば `dog(x) ^ cat(x)` のような、成り立ち得ない連言を指します。
これらは述語間の性質（ex. 推移律、対称律など）や、ルールによって定義されます。

排他制約を表すJSONオブジェクトは、以下の要素を持ちます。

- `"index"` :: 潜在仮説集合における、この排他制約を指すインデックス番号です。
- `"type"` :: この排他制約がどのような出自であるかを表す文字列です。
	- `"counterpart"` :: 同じ論理式の真偽（ `p(x)` と `!p(x)` など）によって生じる排他制約です。
	- `"transitive"` :: 述語の推移律によって生じる排他制約です。
	- `"asymmetric"` :: 述語の非対称律によって生じる排他制約です。
	- `"irreflexive"` :: 述語の非反射律によって生じる排他制約です。
	- `"right-unique"` :: 述語の右一意性によって生じる排他制約です。
	- `"left-unique"` :: 述語の左一意性によって生じる排他制約です。
	- `"rule"` :: ルールによって定義された排他制約です。
	- `"rule-class"` :: ルールのクラスによって生じる排他制約です。
	- `"unknown"` :: それ以外の理由で生成された排他制約です。
- `"atoms"` :: 排他制約が成り立っている連言を、文字列の配列で表します。
- `"rid"` :: この制約を定義しているルールのID番号を記述します。この制約がルールによって定義されたものでない場合、この要素は省略されます。

## Cost Payment

コスト支払いに関する情報を表すJSONオブジェクトは、以下の要素を持ちます。

- `"node"` :: コストが課されているノードのインデックス番号です。
- `"cost"` :: 割り当てられているコストの値です。
- `"paid"` :: コストを支払ったかどうかを表します。

## ILP Variables

ILP変数を表すJSONオブジェクトは、以下の要素を持ちます。

- `"index"` :: ILP問題における、この変数を指すインデックス番号です。
- `"name"` :: この変数の名称です。
- `"coefficient"` :: ILP問題の目的関数における、この変数に割り当てられた係数の値です。
- `"fixed"` :: この変数が定数である場合の値です。定数でない場合は省略されます。

## ILP Constraints

ILP制約を表すJSONオブジェクトは、以下の要素を持ちます。

- `"index"` :: ILP問題における、この制約を指すインデックス番号です。
- `"name"` :: この制約の名称です。
- `"terms"` :: この制約の左辺を、文字列の配列として表します。詳細は後述します。
- `"range"` :: この制約の左辺値が満たすべき値の範囲を文字列で表します。
    - `"= X"` :: 制約式は `X` と等価でなければなりません。
	- `"<= X"` :: 制約式は `X` 以下でなければなりません。
	- `">= X"` :: 制約式は `X` 以上でなければなりません。
	- `"X ~ Y"` :: 制約式は `X` 以上 `Y` 以下でなければなりません。

要素 `terms` の配列における各文字列は、変数のインデックスと、
制約式における、その変数に割り当てられた係数の値を表しています。

例えば `temrs` の配列が `["1.0*[3]", "-1.0*[4]"]` という配列だった場合、
この制約が表す式の左辺は、以下の値の総和であることを表します。

- インデックスが `3` のILP変数の値に、係数 `1.0` を掛けた値
- インデックスが `4` のILP変数の値に、係数 `-1.0` を掛けた値

-----

# Products of KB Compilation

背景知識のコンパイルを行うと `-k` オプションで指定したパスにファイルが生成されます。

各ファイルは以下のような情報を格納しています。

- `*.base.dat.cdb` :: 推論ルールそのものをバイナリで格納しています。
- `*.base.idx.cdb` :: 各推論ルールのID番号と、バイナリ上でのバイト位置を、紐づけるための情報を格納しています。
- `*.cls.cdb` :: ルールクラスからルール集合への対応関係を格納しています。
- `*.lhs.cdb` :: 述語から、その述語を左辺に含むルール集合への対応関係を格納しています。
- `*.rhs.cdb` :: 述語から、その述語を右辺に含むルール集合への対応関係を格納しています。
- `*.ft1.cdb` :: 述語から、その述語を含む連言の集合への対応関係を格納しています。
- `*.ft1.cdb` :: 連言の構成情報から、そのような連言を含むルール集合への対応関係を格納しています。
- `*.predicate` :: 述語のリストをバイナリで格納しています
- `*.heuristic` :: ヒューリスティック関数に関する情報を格納しています。
- `*.spec.txt` :: 背景知識の概要を記述したテキストファイルです。以下の項目を含んでいます。
    - `kb-version` :: 背景知識のデータ構造に関するバージョン番号です。
	- `time-stamp` :: 背景知識をコンパイルした日時です。
	- `num-rules` :: 背景知識に含まれる推論ルールの数です。
	- `num-predicates` :: 背景知識に含まれる述語の種類数です。
	- `heuristic` :: 使用したヒューリスティック関数を表す文字列です。

なお、上記のファイル群のいずれも、推論時に必要となるファイルです。
誤って削除してしまった場合は再度コンパイルを行ってください。


-----

# Advanced Functions

この章では、いくつかの発展的な機能について記述します。

## Rule Class

ルール名に `:` を含めた場合、 `:` よりも前の文字列がそのルールのクラスとして解釈されます。
例えば `animal:dog` という名前のルールは、クラス `animal` に属します。

同じクラスに属するルールは、同一の論理式に対して同時に適用することが出来なくなります。
これを利用することで、例えば以下のように、同じ上位概念を持つ概念間の相互排他性を表現することができます。

	rule animal:dog { dog(x) => animal(x) }
	rule animal:cat { cat(x) => animal(x) }
	rule animal:rat { rat(x) => animal(x) }

なお、Phillip における同等の機能では、ルールクラスによる制約は証明木の構造に対して適用されるものでしたが、
本機能によって定義される制約は、証明木の構造に対するものではなく、論理式に対する制約です。
例えば上記の例では、観測に `animal(A)` が含まれる場合を考えたとき、
論理式 `dog(A)`、`cat(A)`、`rat(A)` のうち2つ以上が `animal(A)` と同時に成り立つような仮説は、
背景知識に矛盾するものとして、候補から除外されます。

また、各ルールが属することが出来るのは一つのルールのみです。
例えば `aaa:bbb:ccc` のような名称を与えた場合でも、そのルールが属するのは `aaa` クラスのみです。

-----

# DavDeb (David Debugger)

`ver.1.65` より、期待する推論が得られない時の検証ツールを提供しています。
この章ではこの検証ツール（`davdeb.py`）について説明します。

## Input

`davdeb.py` を用いるには、以下のデータを用意する必要があります。

- コンパイル済み背景知識
- `require` 要素を含む事例が記述された観測ファイル

`davdeb.py` は実行中にDavidを用いて推論を行いますが、
その際に背景知識のコンパイル処理は行わないので、背景知識は予めコンパイルしておく必要があります。

観測ファイルに複数の事例が含まれていても、`davdeb.py` は最初の一問目だけを対象として解析を行います。

## Usage

Davidを実行する際のオプションおよび入力ファイルを、そのまま `davdeb.py` に渡してください。

例えば通常の推論時におけるコマンドが以下の1行目だったとすると、
`davdeb.py` を実行する時のコマンドは2行目のようになります。

~~~~~
$ bin/david infer -k compiled -c naive,weighted,gurobi --max-depth=5 input.dav
$ tools/davdeb.py -k compiled -c naive,weighted,gurobi --max-depth=5 input.dav
~~~~~

## Output

`davdeb.py` を実行すると、与えられた観測と背景知識が `require` 要素を充足できるかどうかの検証を行います。
以下に出力結果とその対策を記します。

- `error1`

	通常の推論結果を得ることが何らかの理由で不可能です。
	同時に出力されるエラーメッセージを参照してください。

- `error2`

	期待する仮説を `--pseudo-positive` オプションを用いて得ることが、何らかの理由で不可能です。
	同時に出力されるエラーメッセージを参照してください。

- `error3`

	期待する仮説を `--set-const-true` オプションを用いて得ることが、何らかの理由で不可能です。
	同時に出力されるエラーメッセージを参照してください。

- `ok`

	期待する仮説が最適解として得られました。

- `tie_score`

	期待する仮説を含め、最適解が複数存在しています。
	期待する仮説が解仮説として出力されるかどうかが、ソルバ内部の挙動に応じて変化する状態です。

- `not_best`

	期待する仮説は探索空間には含まれていますが、最適解ではありません。

- `impossible`

	期待する仮説はそもそも探索空間に含まれていません。
	この場合、`davdeb.py` は `require` に含まれる論理式のうち
	探索空間に含まれていないもののリストを出力します。

-----

# Detailed Specification

この章では、多くの場合は気にする必要の無い、細かい仕様について記述します。

## Conjunction

ルール中の連言における論理式の順序は、入力ファイルとプログラム内部とで異なる場合があります。

これは、プログラム内部では連言が常に特定の基準でソートされた状態で保持されることに因ります。
具体的には、以下のような順序になるように安定ソートされます。

1. NAFを含まず、かつ等価仮説でもないようなリテラル（ex. `p(x)`）
2. NAFを含み、かつ等価仮説でないようなリテラル（ex. `not p(x)`）
3. NAFを含まない等価仮説 (ex. `(x = y)`)
4. NAFを含む等価仮説（ex. `not (x = y)`）

## Chaining

推論ルールを用いて後ろ向き推論を適用した場合の挙動を詳述します。

以下では、推論ルール `{ P => Q | R }` を用いた後ろ向き推論を、既存の論理式 `Q'` に適用し、
新たに論理式 `P'` が追加された状況を仮定します。

- 論理式 `Q'` は、論理式 `Q ∪ R` のうち、以下の条件を満たすリテラルから成る連言に対応します。（以下、この連言を `E` と表す）
    + NAFを含まない
	+ 等価仮説でない
- 論理式 `E` が空となるような推論ルールは、後ろ向き推論の対象となりません。
- 論理式 `Q'` が論理式 `E` に対応するとは、それらが等価となるような、`E` への変数代入操作 `Φ` が存在することです。
- 論理式 `P'` は、以下の条件のうち少なくとも一つを満たすリテラルから成る連言に対応します。（以下、この連言を `H` と表す）
    + NAFを含む
	+ 等価仮説である
	+ 論理式 `P` に含まれる
- 論理式 `P'` が論理式 `H` に対応するとは、論理式 `H'` に対して以下の操作を行った結果が `P'` であることを表します。
    + 論理式 `H` に含まれる個々の論理変数に対して、変数代入操作 `Φ` を適用する
	+ 変数代入操作 `Φ` の対象に含まれない論理変数には、自由変数を代入する
	+ NAFをTypical Negationに置き換える（ex. `not X` は `!X` に置き換えられる）

例えば、ルール `{ p(x, y) => q(z) ^ not (z = A) | r(x) ^ (x != B) }` を用いた後ろ向き推論を、
論理式 `q(s) ^ r(t)` に適用すると、
新たに追加される論理式は `p(t, u) ^ (s != A) ^ (t != B)` となります。

-----

# Libraries

内部で使用しているライブラリのリストです。

## cdb++

- Author :: Naoaki Okazaki
- License :: [modified BSD](https://opensource.org/licenses/bsd-license.php)
- URL :: http://www.chokkan.org/software/cdbpp/
